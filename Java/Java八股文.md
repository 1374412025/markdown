

# Java八股文

## java

### 面向对象的特征

- 面向对象编程是利用类和对象编程的一种思想。万物可归类,类是对于世界事物的高度抽象,不同的事物之间有不同的关系,一个类自身与外界的封装关系,一个父类和子类的继承关系,一个类和多个类的多态关系。万物皆对象,对象是具体的世界事物,面向对象的三大特征封装,继承,多态。封装,封装说明一个类行为和属性与其他类的关系,低耦合,高内聚;继承是父类和子类的关系,多态说的是类与类的关系。

- 封装隐藏了类的内部实现机制,可以在不彯响使用的情况下改变类的內部结构,同时也保护了数据。对外昇而已它的內部细节是隐藏的,暴露给外界的只是它的访问方法。属性的封装:使用者只能通过事先定制好的方法来访问数据,可以方便地加入逻辑控制,限制对属性的不合理操作;方法的封装:使用者按照既定的方式调用方法,不必关心方法的内部实现,便于使用;便于修改,增强代码的可维护性。
- 继承是从已有的类中派生出新的类,新的类能吸收已有类的数据属性和行为,并能扩展新的能力。在本质上是特殊—般的关系,即常说的is=关系。子类继承父类,表明子类是一种特殊的父类,并且具有父类所不具有的一些属性或方法。从多种实现类中抽象出一个基类,使其具备多种实现类的共同特性,当实现类用 extends关键字继承了基类(父类)后,实现类就具备了这些相司的属性。继承的类叫做子类(派生类或者超类),被继承的类叫做父类(或者基类)。比如从猫类、狗类、虎类中可以袖象岀一个动物,具有和猫、狗、虎类的共同特性(吃.跑、叫等)。Java通过 extends关键字来实现继承,父类中通过 private定义的变量和方法不会被继承,不能在子类中直接操作父类过 private定义的变量以及方法。承避免了对一般类和特殊类之间共同特征进行的重复抽述,通过继承可以清晰地表达每一项共同特征所适应的概念范围,在一般类中定义的禹性和操作适应于这个类木身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。
- 相比于封装和继承,Java多态是三大特性中比较难的一个,封装和继承最后归结于多态,多态指的是类和类的关系,两个类由继承关系,存在有方法的重写,故而可以在调用时有父类引用指向子类对象。多态必备三个要素:继承,重写,父类引用指向子类对象。

### 高并发中的集合

- 第一代线程安全的集合

  vector、hashtable

  全部是synchronized的方法 效率低下

- 第二代非安全集合

  ArrayList、HashMap

  性能好

  使用Collections.synchronizedList(list)、Collections.synchronizedMap(map)

- 第三代安全的集合

  在大量并发情况下如何提高集合的效率和安全呢
  java.util.concurrent.*
  Concurrenthashmap
  Copyonwritearraylist
  Copyonwritearrayset:注意不是 Copyonwritehashset'*
  底层大都采用Lok锁(1.8的 Concurrenthashmap不使用Lock锁),保证安全的同时,性能也很高。

### jdk1.8 的新特性

- 接口的默认方法
- lambda表达式
- 函数式接口
- stream API
- 时间API

### Java接口和抽象类的区别

相同：

- 不能够实例化
- 可以将抽象类和接口类型作为引用类型
- 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中所有的抽象方法进行实现，否则任然需要被定义为抽象类

不同：

- 抽象类
  - 可以定义构造器
  - 有抽象方法和具体方法
  - 成员全部都是public的
  - 可以定义成员变量
  - 有抽象方法的类必须被定义成抽象类，而抽象类不一定需要定义抽象方法
  - 可以包含静态方法
  - 一个类只能继承一个抽象类
- 接口
  - 无构造器
  - 只有抽象方法
  - 可以是private、默认、protected、public
  - 定义的成员变量实际上是常量
  - 无静态方法
  - 一个类可以实现多个接口

### String、String Buffer、StringBuilder的区别和使用场景

Java提供了两种字符串类型：String和StringBuffer/StringBuilder，都可以用于储存和操作字符串

- 区别如下：
  1. String是只读字符串，内容无法被更改，因为其出现后被视为常量，只能更改指针的指向。
  2. StringBuilder/StringBuffer的字符串内容可以被修改，其被视为一个对象，放在堆中。
  3. StringBuilder在java5中引入，其方法与StringBuffer相同区别在于StringBuilder是线程不安全的，并没有synchronized修饰因此其效率比StringBuffer高

### final修饰符

- 修饰变量时，被修饰的变量被赋初始值后，不能重新赋值
- 修饰方法时，被修饰的方法不能重写
- 修饰类时，被修饰的类不能派生子类

### 自定义异常的使用场景

1. 系统中有些错误是符合Java语法,但不符合业务逻辑。
2. 在分层的软件结构中,通常是在表现层统一对系统其他层次的异常进行捕获处理。

## JVM

### 对象的创建过程

### DCL要不要加volatile

### 对象在内存中的存贮布局

![image-20230228130104205](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230228130104205.png)

mark word （8字节）

class pointer（4字节）

instance data（看实际情况）

padding（填充为能被8整除）

### 对象头具体包括什么

mark word+class pointer  

mark word 包含的信息

- 锁信息
- hashcode
- gc信息

### 对象的定位

![image-20230228131555103](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230228131555103.png)

### 对象的分配

![image-20230228133329624](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230228133329624.png)

### Object 0 = new Object（）在内存中占据多少字节	

16个字节

### 类初始化的过程

- 类加载的过程：

  *加载、验证、准备、解析、初始化* 几个阶段

  ![image-20230228140448947](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230228140448947.png)

- 装载：装载是指JVM找到class文件生成字节流，然后根据字节流创建java.lang.Class对象的过程。

  1. [ClassLoader](https://so.csdn.net/so/search?q=ClassLoader&spm=1001.2101.3001.7020)通过一个类的包名+类型来查找.class文件。并生成二进制字节流。
  2. 把class文件解析为JVM内部的数据结构，并存储在方法区。（这种解析类似json文件解析成运行时的bean类）
  3. 在内存中创建一个java.lang.Class类型的对象。

- 验证：验证是链接的第一步，目的是为了确保.class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危及虚拟机本身的安全。主要包含以下几个方面的检验。

  - 文件格式检验：检验字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理。
  - 元数据检验：对字节码描述的信息进行语义分析，以保证其描述的内容符合 Java 语言规范的要求。
  - 字节码检验：通过数据流和控制流分析，确定程序语义是合法、符合逻辑的。
  - 符号引用检验：符号引用检验可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。

- 准备：准备是链接的第 2 步，这一阶段的主要目的是为类中的静态变量分配内存，并为其设置“0值”。

- 解析：解析是链接的最后一步，这一阶段的任务是把常量池中的符号引用转换为直接引用，也就是具体的内存地址。在这一阶段，JVM会将常量池中的类、接口名、字段名、方法名等转换为具体的内存地址。

- 初始化：将标记为static的字段进行赋值，并且执行static标记的代码语句 。这是 class 加载的最后一步，这一阶段是执行类构造器方法的过程，并真正初始化类变量。

### Java的类加载器

- Bootstrap类加载器（启动）

  启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。

- Extension类加载器（扩展）

  扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。

- System类加载器（Application类加载器）

  也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。

### 双亲委派机制

- 双亲委派模式是在ava1.2后引入的,其工作原理的是,如果一个类加载器收到了类加载请求,它并不会自己先去加载,而是把这个请求委托给父类的加载器去执行,如果父类加载器还存在其父类加载器,则进一步向上委托,依次递归,请求最终将到达顶层的启动类加载器,如果父类加载器可以完成类加载任务,就成功返回,倘若父类加载器无法完成此加载任务,子加载器才会尝试自己去加载,这就是双亲委派模式

- 优势
  - 每个类只会被加载一次，避免了重复加载
  - 每一个类都会被尽可能的加载（从系统加载器往下，每个加载器都可能会根据优先次序尝试加载它）
  - 有效避免了某些恶意类的加载（比如自定义的Object类）

### jvm内存分配模型

> ![image-20230228144534373](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230228144534373.png)

五个部分：堆内存、方法区、本地方法栈、程序计数器、Java栈

![image-20230228144731747](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230228144731747.png)

- Java栈：每个线程有—个私有的栈,随着线程的创建而创建。栈里面存着的是一种叫“栈帧的东西,每个方法会创建一个栈帧,栈帧中存放了局部变量表(基本数据类型和对象引用)、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。当栈调用深度大于M所允许的范围,会抛出 Stackoverflow Error的错误

  - 局部变量表随着栈帧的创建而创建,它的大小在编译时确定,创建时只需分配事先规定的大小即可。在方法运行过程中,局部变量表的大小不会发生改变
  - java虛拟机栈也是线程私有,随着线程创建而创建,随着线程的结束而销毁
  - java虚拟机栈会出现两种异常: Stackover Flow Error(若」ava虚拟机栈的大小不允许动态扩展,那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度时,抛出 Stackover Flowerr异常)和Outofmemoryerror(若允许动态扩展,那么当线程请求栈时内存用完了,无法再动态扩展时,抛出Outofmemoryerror异常

  ![image-20230228145223397](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230228145223397.png)

- 本地方法栈：本地方法栈是为M运行 Native方法准备的空间,由于很多 Native方法都是用C语言实现的,所以它通常又叫栈。它与Java虛拟机栈实现的功能类似,只不过本地方法栈是描述本地方法运行过程的内存模型。本地方法被执行时,在本地方法栈也会创建一块栈帧,用于存放该方法的局部变量表、操作数栈动态链接、方法出口信息等。方法执行结束后,相应的栈帧也会出栈,并释放内存空间。也会抛出Stackover Flow Error和 Outofmemoryerror异常。

- pc计数器：毎个线程都有一个程序计数器,是线程私有的,就是一个指针,指向方法区中的方法字节码(用来存储指向像条指令的地址,也即将要执行的指令代码),在执行引擎读取下一条指令,是个非常小的内存空间,几乎可以忽略不计

- 堆：堆内存是丿M所有线程共享的部分,在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过GC进行回收。当申请不到空间时会抛出 Outofmemoryerror

  - 线程共享,整个Java虛拟机只有一个堆,所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个
  - 在虚拟机启动时创建
  - gc的主要场所
  - 一般采用分代回收算法

- 方法区：堆的逻辑部分

  - 方法区也是所有线程共享。主要用于存储已经被虚拟杋加载的类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的—部分,但是为了与堆进行区分,通常又叫非堆。需要注意的是,方法区只是规范上面的一个逻辑概念,并不是真实的物理存储的命名

## 并发编程

### ABA问题

1. 有两个线程同时去修改一个变量的值,比如线程1、线程2,都更新变量值,将变量值从A更新成B。
2. 首先线程1获取到CPU的时间片,线程2由于某些原因发生阻塞进行等待,此时线程1进行比较更新( Compareandswap),成功将变量的值从A更新成B
3. 更新完毕之后,恰好又有线程3进来想要把交量的值从B更新成A,线程3进行比较更新,成功将变量的值从B更新成A。
4. 线程2获取到PU的时间片,然后进行比较更新,发现值是预期的A,然后有更新成了B。但是线程1并不知道,该值已经有了A>B->A这个过程,这也就是我们常说的ABA问题。

例如：

小明在提款机,提取了50元,因为提款机问题

有两个线程,同时把余额从100变为50

线程1(提款机):获取当前值100,期望更新为50

线程2(提款机):获取当前值100,期望更新为50,

线程1成功执行,线程2某种原因bock了,这时,某人给小明汇款50

线程3(默认):获取当前值50,期望更新为100,

这时候线程3成功执行,余额变为100,

线程2从Bock中恢复,获取到的也是100, compare之后,继续更新余额为50!!!

此时可以看到,实际余额应该为100(100-50+50),但是实际上变为了50(100-50+50-50)

如何避免：

通过加版本号或者时间戳解决，或者保证单向递增或单向递减来解决

atomic包下的 Atomicstampedreference类:其 compareandse方法首先检查当前引用是否等于预期引用,并且当前标志是否等于预期标志,如果全部相等,则以原子方式将该引用的该标志的值设置为给定的更新值。

### synchronized 和lock的区别

1. 来源：lock是一个接口,而 synchronized是java的一个关键字, synchronized是内置的语言实现
2. 异常是否释放锁：synchronized在发生异常时候会自动释放占有的锁,因此不会出现死锁;而lck发生异常时候,不会主动释放占有的锁,必须手动 unlock来释放锁,可能引起死锁的发生。(所以最好将同步代码块用 try catch包起来,finally中写入 unlock,避免死锁的发生）
3. 是否响应中断：lock等待锁过程中可以用 interrupt来中断等待,而 synchronized只能等待锁的释放,不能响应中断;
4. 是否知道获取锁：LoCk可以通过 trylock来知道有没有获取锁,而 synchronized不能;
5. lock可以提高多个线程进行读操作的效率。(可以通过 readwritelock实现读写分离)
6. 在性能上来说,如果竟争资源不激烈,两者的性能是差不多的,而当竞争资源非常激烈时(即有大量线程同时竟争),此时Lock的性要远远优于 synchronized。所以说,在具体使用时要根据适当情况选择
7. synchronized使用obje对象本身的wat、noty、noA调度机制,而Lock可以使用 Condition进行线程之间的调度

![image-20230228151139088](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230228151139088.png)

### synchrinized 和ReentrantLock的区别

1.  **底层实现**上来说，synchronized 是**JVM**层面的锁，是**Java关键字**，通过monitor对象来完成（monitorenter与monitorexit），对象只有在同步块或同步方法中才能调用wait/notify方法，ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的**API层面**的锁。

   synchronized 的实现涉及到锁的升级，具体为无锁、偏向锁、自旋锁、向OS申请重量级锁，ReentrantLock实现则是通过利用CAS（CompareAndSwap）自旋机制保证线程操作的原子性和volatile保证数据可见性以实现锁的功能。

2. **是否可以手动释放**： synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try/finally语句块来完成，使用释放更加灵活。

3. **是否可中断**： synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。

4. **是否为公平锁：**synchronized为非公平锁 ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。

5. **锁是否可绑定条件Condition：**synchronized不能绑定； ReentrantLock通过绑定Condition结合await()/singal()方法实现线程的精确唤醒，而不是像synchronized通过Object类的wait()/notify()/notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程。

6. **锁的对象**：synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁/争抢锁；ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得/争抢。

### volatile的可见性和禁止指令重排的实现

> 观察加入 volatile关键字和没有加λ volatile关键字时所生成的汇编代码发现,加入ν olatile关键字时,会多岀一个lock前缀指令

lock前缀——内存屏障：

1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置,也不会把前面的指令排到内存屏障的后面;即在执行到内存屏障这句指令时,在它前面的操作已经全部完成;
2. 它会强制将对缓存的修改操作立即写入主存;
3. 如果是写操作,它会导致貝其它CPU中对应的缓存行无效

- 可见性：volatile的功能就是被修饰的变量在被修改后可以立即同步到主内存,被修饰的变量在每次是用之前都从主内存刷新。本质也是通过内存屏障来实现可见性写内存屏障( Store Memory Barrier)可以促使处理器将当前 store buffer(存储缓存)的值写回主存。读内存屏障( Load Memory Barrier)可以是使处理器处理 invalidate queue(失效队列)。进而避免由于 StoreBuffer和 validate Queue的非实时性带来的问题
- 禁止指令重排：volatile通过内存屏障来实现禁止指令重排

### 程序开线程的数量

- CPU密集型程序：一个完整请求,IO操作可以在很短时间内完成,CPU还有很多运算要处理,也就是说CPU计算的比例占很大一部分,线程等待时间接近0
  - 单核CPU:一个完整请求,I/O操作可以在很短时间内完成,CPU还有很多运算要处理,也就是说CPU计算的比例占很大—部分,线程等待时间接近0。单核CPU处理CPU密集型程序,这种情况并不太适合使用多线程
  - 多核:如果是多核CPU处理CPU密集型程序,我们完全可以最大化的利用CPU核心数,应用并发编程来提高效率。CPU密集型程序的最佳线程数就是:理论上线程数量=CPU核数(逻辑),但是实际上,数量一般会设置为CPU核数(逻辑)+1(经验值),计算(CPU)密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停,刚好有一个额外的线程,可以确保在这种情况下CPU周期不会中断工作
- I/O密集型程序：与CPU密集型程序相对,一个完整请求，CPU运算操作完成之后还有很多I/O操作要做,也就是说I/O操作占比很大部分,等待时间较长,线程等待时间所占比例越高,需要越多线程;线程CPU时间所占比例越高,需要越少线程
  - I/O密集型程序的最佳线程数就是:最佳线程数=CPU核心数(CPU利用率=CPU核心数(1+(I/O耗时/CPU耗时）
  - 如果几乎全是I/O耗时,那么CPU耗时就无限趋近于0,所以纯理论你就可以说是2N(N=CPU核数),当然也有说2N+1的,1应该是 backup

### 创建线程的方式：

1. 继承Thread类创建线程
   - 定义Thread的子类，重写run方法，该方法就是该线程要完成的主要认为，也被称为线程执行体
   - 创建Thread子类的实例，也就是创建线程对象
   - 启动线程即调用线程的start（）方法
2. 实现Runnable接口创建线程
   - 定义Runnable接口的实现类，一样要重写run方法
   - 创建对应的实例，并用这个实例作为Thread的target来创建一个Thread对象。
   - 通过start来启动
3. 实现Callable接口创建线程
   - 与Runnable接口不同，Callable接口提供了call()方法作为线程执行体，
     - call()方法有返回值
     - call()方法可以声明抛出异常
   - ![image-20230228154715581](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230228154715581.png)
   - 创建Callable接口的实现类，并实现call()方法，然后创建对应的实例（Java1.8以后可以使用lambda表达式创建Callable对象）
   - 使用FutureTask类来包装Callable对象，该FutureTask封装了Callable对象的call()方法的返回值
   - 使用FutureTask对象作为Tread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）
   - 调用FutureTask对象的get()方法来获取子线程的返回值
4. 使用线程池创建线程

### 线程的生命周期和状态

![image-20230228163712911](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230228163712911.png)

### 内存溢出的原因

第一类异常堆栈内存溢出

- java. lang. Outofmemory Error:…… java heap space…

  也就是当你看到heap相关的时候就肯定是雄栈溢出了,此付如果代碍没有问誕的情况下,适当调整Xmx和Xms是可以避免的,不过一定是代码没有问题的前提,为什么会溢出呢,要么代码有问题,要么访问量太多并且每个访问的时间太长或者数据太多,导致数据释放不掉,因为垃圾回收器是要找到形些是垃圾才能回收,这里它不会认为这些东西是垃圾,自然不会去回收了;

- java.lang. Outofmemony Error: GC over head limit exceeded

  该情况是系统处于高频GC的情况下，回收的效果依然不佳的情况，就会开始报此错误

第二类异常PermGen的溢出

- java . lang . Outofmemoryerror : Permgen space

  系统的代码非常多或者引用的第三方包非常多，或代码中使用了大量的常量，或通过intern注入常量，或者通过动态代码加载等方法，导致常量池的膨胀。

第三类异常方法栈溢出

- java, lang. Stackoverflowerror

  这个参数直接说明一个内容，就是-Xss太小了，我们申请很多局部调用的栈指针内容是存放在用户当前所持有的线程中的，线程在jdk1.4之前默认256k，1.5以后是1M，如果报这个错，只能说明-Xss的值设置小了。

第四类异常线程区域创建失败异常

- java.lang.OutOfMemoryError:unable to create new native thread

  上面第三种错误，已经说明了线程的内存空间，其实线程基本只占用heap以外的内存空间也就是这个错误说明除了heap以外的区域，无法为线程分配一块内存区域了，要么是内存不足，要么是heap空间设置太大，导致剩余的内存已经不多了而由于线程本身要占用内存，所以就不够用了。

第五类异常地址空间不足

- java.lang.OutOfMemoryError:request{}byte for 	{} out of swap 

### 预防死锁

![image-20230228172703812](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230228172703812.png)

死锁发生的四个必要条件：

1. 互斥：同一时间只能有一个线程获取资源
2. 不可剥夺：一个线程如果已经占用了资源，在释放之前不会被其它线程抢占
3. 请求和保持：线程等待过程中不会释放已占有的资源
4. 循环等待：多个线程互相等待对方释放资源

### 守护线程

在java中有两类线程：User Thread（用户线程）、Deamon Thread（守护线程）

任何一个守护线程都是jvm中非守护线程的保姆

只要当前VM实例中尚存在任何ー个非守护线程没有结東,守护线程就全部工作;只有当最后一个非守护线程结束时,守护线程随着VM一同结束工作。 Daemon的作用是为其他线程的运行提供便利服务,守护线程最典型的应用就是GC(垃圾回收器),它就是一个很称职的守护者。

User和 Daemon两者几乎没有区别,唯一的不同之处就在于虚拟机的离开:如果 User thread已经全部退出运行了,只剩下 Daemon thread存在了,虚拟机也就退出了。因为没有了被守护者, Daemon也就没有工作可做了也就没有继续运行程序的必要了。

### 线程池

java线程池的创建非常昂贵，需要JVM和OS配合完成大量操作

1. 必须为线程堆栈分配和初始化大量内存块，其中包含至少1MB的栈内存
2. 需要进行系统调用，以便在OS中创建和注册本地线程

Java高并发应用频繁的创建和销毁线程的操作是非常低效的，而且是不被编程规范所允许的。如何降低Java线程的创建成本，必须使用线程池。

- 提升性能：线程池能独立负责线程的创建、维护和分配。在执行大量异步任务时,可以不需要自己创建线程,而是将任务交给线程池去调度。线程池能尽可能使用空闲的线程去执行异步仼务,最大限度地对已经创建的线程进行复用,使得性能提升明显。
- 线程管理：每个ava线程池会保持一些基本的线程统计信息,例如完成的任务数量、空闲时间等,以便对线程进行有效管理,使得能对所接收到的异步仼务进行高效调度。

### 线程的命令

**sleep**：

- 作用：让目前正在执行的线程休眠，让CPU去执行其他的任务。从线程状态来说，就是从执行状态变为限时阻塞状态。sleep()方法是定义在Thread的静态方法，有两个重载版本:

  ![image-20230228180249678](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230228180249678.png)

- sleep()会有InterrupException受检异常抛出，如果调用了sleep()方法，就必须进行异常审查，捕获InterrupException异常，或者再次通过方法声明该异常的存在。

**wait**（必须先获取锁才能调用）：让线程进入等待状态，释放当前线程所拥有的锁资源，线程只有在notify或者notifyAll方法调用以后才会被唤醒，然后去争夺锁。

**join**：线程之间的协同方式，使用场景：线程A必须等到线程B运行完毕才可以执行，那么就可以在线程A中加入TreadB.join();

**yield**:让当前正在执行的线程回到可执行状态，以允许有相同优先级别的线程获取运行的机会，因此,使用yield0的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是,实际中无法保证 yield(达到让步的目的,因为,让步的线程可能被线程调度程序再次选中

-  yield仅能使一个线程从运行状态转到就绪状态,而不是阻寒状态。
- yield不能保证使得当前正在运行的线程迅速转换到就绪状态。
- 即使完成了迅速切换,系统通过线程调度机制从所有就绪线程中挑选下一个执行线程时,就绪的线程有可能被选中,也有可能不被选中,其调度的过程受到其他因素(如优先级)的影响

### sleep和wait的区别

![image-20230301122903844](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230301122903844.png)

## Mysql

### 四种隔离级别

- Serializable（序列化）：解决幻读的问题

  采用此隔离级别时，一个事务在执行过程中首先将其欲操纵的数据锁定，待事务结束后释放。如果此时另一个事务也要操纵该数据，必须等待前一个事务释放锁定后才能继续进行，也就是两个事务串行进行，用户之间通过依次顺序执行当前事务，就提供了事务之间最大限度的隔离。

- Repeatable Read（可重复读）：Mysql默认的隔离级别

  采用此隔离级别时，一个事务在执行过程中可以看到其他事务已经提交的新插入记录，不能看到其它事务对已有数据的修改，在这一级，事务不会被视为一个序列，不过当前在执行事务的变化任然不能看到，也就是说，如果一个用户在同一个事务中执行同一个SELECT命令时，得到的结果总是相同的。可能导致 **幻读** 的问题，InnoDB和Falcon存储引擎通过多版本并发控制来解决此问题。

- Read Committed （提交读）：系统默认的隔离级别（但不是Mysql的默认隔离级别）

  采用此隔离级别，一个事务在执行过程中能够看到其它事务已经提交的新插入的记录，也能看到其他事务已经提交的对已有记录的修改，这一级安全性更低，不仅处于这一级的事务可以看到其他事务添加的新纪录，而且其他事务对现存记录做出的修改一旦被提交，也可以看到，也就是说，这意味着事务处理期间，如果其它事务修改了相应的表，那么同一个事务的SELECT语句得到的结果可能不同。可能导致 **幻读、不可重复读**的问题。

- Read Committed（未提交读）

  采用此隔离级别，一个事务在执行过程中能够看到其它事务未提交的新插入的记录，也能看到其他事务已经提交的对已有记录的修改，提供了事务之间最小限度的隔离，由于可能会读到未提交的数据，导致 **脏读** 的问题，同时存在**幻读、不可重复读**的问题。

- **脏读**：脏读是指一个事务读取了未提交事务执行过程中的数据。当一个事务的操作正在多次修改数据,而在事务还未提交的时候,另外一个并发事务来读取了数据,就会导致读取到的数据并非是最终持久化之后的数据,这个数据就是脏读的数据。

- **不可重复读**：不可重复读是指对于数据库中的某个数据,一个事务执行过程中多次查询返回不同查询结果,这就是在事务执行过浧中,数据被其他事务提交修改了。不可重复读同脏读的区别在于,脏读是一个事务读取了另一未完成的事务执行过程中的数据,而不可重复读是一个事务执行过程中,另一事务提交并修改了当前事务正在读取的数据。

- **幻读**：幻读是事务非独立执行时发生的一种现象,例如事务T1批量对一个表中某一列列值为1的数据修改为2的变更,但是在这时,事务T2对这张表插入了一条列值为1的数据,并完成提交。此时,如果事务T1查看刚刚完成操作的数据,发现还有一条列值为1的数据没有讲行修改,而这条数据其实是T2刚网提交插入的,这就是幻读。幻读和不可重复读都足读取了另一条已经提交的事务(这点同脏读不同),所不同的是不可重复读查询的都足同个数据项,而幻读针对的是一批数据整体(比如数据的个数）

### MyISAM与InnoDB 的区别

1.  InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；

2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； 

3. InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

   MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

   也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。

4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；
5. **Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了**
6. **MyISAM表格可以被压缩后进行查询操作**
7. **InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁**
8. **InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有**

如何选择：

1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。
3.  系统奔溃后，MyISAM恢复起来更困难，能否接受；
4.  MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。

### 为什么MySQL索引结构采用B+树：

存储引擎一般采用B树或者B+树

B树：多路平衡树，用于存储大量的数据整体高度比二叉树矮很多，对于数据库而言，所有的数据都保存在磁盘上，磁盘的IO效率一般比较低（特别实在随机磁盘的IO情况下），矮的树可以大大减少IO操作的次数，从而提高效率。

B+树：相比B树有两个优化：

1、B+树的数据都存储于叶子节点，非叶子节点只存储索引

2、叶子节点使用双向链表进行关联，

采用B+树的原因：

1、从IO效率来看，B+树的非叶子节点不存储数据，树的非叶子节点层就能存储更多的索引数据，从而减少磁盘的IO次数

2、范围查询的效率上，因为叶子节点上有双向链表来关联，在范围查询时只需要查询两个节点进行遍历即可，B树需要查询所有节点。

3、全表扫描：B+树的叶子节点存储了所有的数据，所以B+树的全局扫描会更快，因为只需要扫描叶子节点

4、自增ID：若采用自增Id做为组件，基于B+树的数据结构，可以更好的避免增加数据带来的叶子节点分裂。

### 聚簇索引和非聚簇索引的区别和优缺点：

- 聚簇索引（Clustered Index）并不是一种单独的索引类型，而是一种数据存储方式。当表有了聚簇索引的时候，表的数据行都存放在索引树的叶子页中。无法把数据行放到两个不同的地方，所以一张表只允许有一个聚簇索引。InnoDB的聚簇索引实际上是将索引和数据保存中同一个B-Tree中。InnoDB通过主键聚集数据，如果没有定义主键，InnoDB会选择一个唯一的的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

  - 优势：

    1. 数据访问更快，由于聚簇索引将索引和数据保存在同一个B+树中，所以从聚簇索引中获取数据比非聚簇索引更快
    2. 聚簇索引对于主键的排序查找和范围查找速度很是快

  - 缺点：

    1、插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，不然将会出现页分裂，严重影响性能。所以，对于InnoDB表，咱们通常都会定义一个自增的ID列为主键

    2、更新主键的代价很高，由于将会致使被更新的行移动。所以，对于InnoDB表，咱们通常定义主键为不可更新。

    3、二级索引访问须要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

    4、更新聚集索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置

- 非聚簇索引（NoClustered Index），又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。

  1. 在MyISAM引擎索引和数据是分开存储的，而InnoDB是索引和数据是一起以idb文件的形式进行存储的。
  2. 在访问速度上，聚簇索引比非聚簇索引快。非聚簇索引需要先查询一遍索引文件，得到索引，跟据索引获取数据。而聚簇索引的索引树的叶子节点的直接指向要查找的数据行。

- 存储引擎是InnoDB, 在data目录下会看到2类文件：.frm、.ibd

  （1）*.frm--表结构的文件。

  （2）*.ibd--表数据文件

   

  存储引擎是MyISAM, 在data目录下会看到3类文件：.frm、.myi、.myd 

  （1）*.frm--表定义，是描述表结构的文件。

  （2）*.MYD--"D"数据信息文件，是表的数据文件。

  （3）*.MYI--"I"索引信息文件，是表数据文件中任何索引的数据树

### 索引的基本原理

- **为什么要有索引**：般的应用系统,读写比例在10:1左右,而且插λ操作和一般的更新操作很少岀现性能问题,在生产环境中,我们遇到最多的,也是最容易出问题的,还是一些复杂的查询操作,因此对查询语句的优化显然是重中之重。说起加速查询,就不得不提到索引了

- **索引是什么**：索引在 MYSQL中也叫是一种键,是存引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键,尤其是当表中的数据量越来越大时,索引对于性能的影响愈发重要。索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。索引相当于字典的音序表,如果要查某个字,如果不使用音序表,则需要从几百页中逐页去查。

- **索引的原理：**通过不断地缩小想要取数捃的范囯来筛选出最终想要的结果,同时把机的事件变成顺序的事件,也就是说,有了这种索引机制,我们可以总是用同一种查找方式来锁定数据。

- **索引的数据结构**：

  ![image-20230302131204174](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230302131204174.png)

### MySQL中索引的类型：

1. 普通索引：在创建索引时不附加任何限制条件，可以创建在任何数据类型中，其值是否唯一和非空由字段本身的完整性约束条件决定。即允许被索引的数据列存在重复的值。
2. 唯一索引：限制索引的值必须是唯一的值，可以保证数据记录的唯一性，主键查询就是一种特殊的唯一性索引。
3. 全文索引：在定义索引的字段上支持值的全文查找，允许这些索引字段插入重复的值和空值，全文索引可以在char、varchar或text类型字段上建立，MySQL中只有MyISAM支持全文索引。
4. 单列索引：在表的单个字段上创建索引，单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一索引，还可以是全文索引，只要保证该索引只对应一个字段即可。
5. 多列索引：在表的多个字段上创建一个索引，该索引指向创建时对应的多个字段，可以通过这几个字段进行查询。但是，只要查询条件使用了这些字段中的第一个字段时，索引才会被使用。
6. 空间索引：空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率，MySQL中包含的空间数据类型包括：Geometry、Point、Linestring、Polygon。目前只有M有ISAM存储引擎支持空间索引，而且索引的字段不能为空。

### 索引的设计原则：

1. 适合索引的列是现在 where字句中的列,或者连接子句中指定的列
2. 基数较小的表,索引效果差,没必要创建索引
3. 在选择索引列的时候,越短越好,可以指定某些列的一部分,没必要用全部字段的值
4. 不要给表中的每一个字段都创建索引,并不是索引越多越好
5. 定义有外键的数据列一定要创建索引
6. 更新频繁的字段不要有索引
7. 创建索引的列不要过多,可以创建组合索引,但是组合索引的列的个数不建议太多
8. 大文本、大对象不要创建索引

### 处理Mysql中的慢查询

1. 开启慢查询日志,准确定位到哪个sq语句出现了问题
2. 分析sql语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写
3. 分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引
4. 如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表

### MySQL的日志：

**Redo log, bin log, Undo log**

InnoDB中通过undo log实现了数据的多版本，而并发控制通过锁来实现。

- **binlog**：是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的, 另外通过解析binlog能够实现mysql到其他数据源（如ElasticSearch)的数据复制。

- **redo log**记录了数据操作在物理层面的修改，mysql中使用了大量缓存，缓存存在于内存中，修改操作时会直接修改内存，而不是立刻修改磁盘，当内存和磁盘的数据不一致时，称内存中的数据为脏页(dirty page)。为了保证数据的安全性，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中, redo log是按照顺序写入的，磁盘的顺序读写的速度远大于随机读写。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。这样实现了事务的原子性、一致性和持久性。

- **undo log**: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC。undo log除了实现MVCC外，还用于事务的回滚。MySQL Innodb中存在多种日志，除了错误日志、查询日志外，还有很多和数据持久性、一致性有关的日志。

### MySQL中的锁

- 属性分类：
  1. 读锁（共享锁）：简称S锁;当一个事务为数据加上读锁之后,其他事务只能对该数据加读锁,而不能对数据加写锁,直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据,读取数据的时候不支持修改,避免岀现重复读的问题
  2. 写锁（排他锁）：简称Ⅹ锁;当—个事务为数据加上写锁时,其他请求将不能再为数据加任何锁,直到该锁释放之后,其他事务才能对数据进行加锁。排他锁的囯的是在数据修改时候,不允许其他人同时修改,也不允许其他人读取,避免了出现脏数据和脏读的问题
- 粒度分类：
  1. 表级锁（table lock）：表锁是指上锁的时候锁住的是整个表,当下一个事务访问该表的时候,必须等前一个事务释放了锁才能进行对表进行访问;特点:粒度大,加锁简单,容易冲突;
  2. 行级锁：行锁是指上锁的时候锁住的是表的某一行或多行记录,其他事努访问同—张表时,只有被锁住的记录不能访问,其他的记录可正常访问,特点:粒度小,加锁比表锁麻烦,不容易冲突,相比表锁支持的并发要高
  3. 页锁：页级锁是 MYSQL中锁定粒度介于行级锁和表级锁中间的一种锁.表级锁速度快,但冲突多,行级冲突少但速度慢。所以取了折衷的页级,一次锁定相邻的一组记录。特点:开销和加锁时间界于表锁和行锁之间,会出现死锁;锁定粒度界于表锁和行锁之间,并发度一般。
  4. 记录锁（Record lock）：记录锁也属于行锁中的一种,只不过记录锁的范围只是表中的某一条记录,记录锁是说事务在加锁后锁住的只是表的某一条记录,加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题,也避免了在修改的事务未提交前被其他事务读取的脏读问题
  5. 间隙锁：是属于行锁的一种,闫隙锁是在事务加锁后其锁住的是表记录的某一个区间,当表的相邻D之间出现空隙则会形成一个区间,遵循左开右闭原则。范围查询并且查询未命中记录,查询条件必须命中索引、间隙锁只会出现在 REPEATABLE_READ(重复读)的事务级别中。
  6. 临键锁：也属于行锁的一种,并且它是 LINNODB的行锁默认算法,总结来说它就是记录锁和间隙锁的组合,临键锁会把查询岀来的记录锁住,同时也会把该范围査询内的所有间隙空间也会锁住,再之它会把相邻的下一个区间也会锁住

### MVCC（多版本并发控制）

- 数据库通常使用锁来实现隔离性。最原生的锁，锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景，很多数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。所以就使用了一种读写锁的方法，读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。之后人们发现并发读还是不够，又提出了能不能让读写之间也不冲突的方法，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据。当然快照是一种概念模型，不同的数据库可能用不同的方式来实现这种功能。
- MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。

### MySQL主从同步

- 为什么需要主从复制：
  1. 在业务复杂的系统中,有这么一个情景,有一句sql语句需要锁表,导致暂时不能使用读的服务,那么就很影响运行中的业务,使用主从复制,让主库负责写,从库负责读,这样,即使主库出现了锁表的情景,通过读从库也可以保证业务的正常运作
  2. 做数据的热备
  3. 架构的扩展。业务量越来越大,访问频率过髙,单机无法满足,此时做多库的存储,降低磁盘I/O访问的频率,提高单个机器的I/O性能
- 主从复制：MYSQL主从复制是指数据可以从个MSQL数据库服务器主节点复制到一个或多个从节点。 MYSQL默认采用异步复制方式,这样从节点不用一直访问主服务器来更新自己的数据,数据的更新可以在远程连接上进行,从节点可以复制主数据库中的所有数据库或者特定的数据库,或者特定的表。

## Redis

### 数据类型：

- 五种基本数据类型：
  1. String：二进制安全的字符串
  2. List：按插入顺序排序的字符串元素的集合。他们基本上就是*链表（linked lists）*。
  3. Set: 不重复且无序的字符串元素的集合。
  4. ZSet：Sorted sets,类似Sets,但是每个字符串元素都关联到一个叫*score*浮动数值（floating number value）。里面的元素总是通过score进行着排序，所以不同的是，它是可以检索的一系列元素。（例如你可能会问：给我前面10个或者后面10个元素）。
  5. Hash： 是一个键值(key=>value)对集合，是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。
- 不常用的数据类型：
  1. Bit arrays (或者说 simply bitmaps): 通过特殊的命令，你可以将 String 值当作一系列 bits 处理：可以设置和清除单独的 bits，数出所有设为 1 的 bits 的数量，找到最前的被设为 1 或 0 的 bit，等等。
  2. HyperLogLogs: 这是被用于估计一个 set 中元素数量的概率性的数据结构。
  3. Streams:5.0版本新增， append-only collections of map-like entries that provide an abstract log data type.
     - 可以用来做持久化的消息队列

### 持久化机制

Redis是内存数据库,如果不将内存中的数据库状态保存到磁盘,那么一旦服务器进程退岀,服务器中的数据库状态也会消失。所以 Redis提供了持久化功能!redis提供了不同级别的持久化方式

- RDB：数据备份文件，就是把内存中的所有数据都记录到磁盘中，当Redis实例出现故障重启后，从磁盘读取快照文件，恢复数据。（Redis默认的持久化机制）

  ![image-20230302153335657](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230302153335657.png)![image-20230302153353754](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230302153353754.png)

  - 基本流程：
    1. fork主进程得到一个子进程，共享内存空间
    2. 子进程读取内存数据并写入新的RDB文件
    3. 用新的RDB文件替换旧的RDB文件

  - 缺点：
    1. RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险
    2. fork子进程、压缩、写出RDB文件都比较耗时

- AOF：追加文件，Redis处理的每一个命令都保存在AOF文件中（命令日志文件）

  ![image-20230302153803467](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230302153803467.png)

  ![image-20230302153829701](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230302153829701.png)![image-20230302153836777](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230302153836777.png)

- 对比：

  ![image-20230302153855228](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230302153855228.png)

## springboot

### spring、spring MVC、spring boot的区别

- spring和springmvc：
  1. spring是一个—站式的轻量级的ava开发框架,核心是控制反转(IOC)和面向切面(AOP),针对于开发的WEB层( springMVC)、业务层(IOC）、持久层 (jdbctemplate)等都提供了多种配置解决方案;
  2. springmvc是 spring基础之上的一个MVC框架,主要处理web开发的路径映射和视图渲染,属于 spring框架中WEB层开发的一部分
- springMVC 和spring boot：
  1. springmvc属于一个企业WEB开发的MV框架,涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等,XML、 config等配置相对比较繁琐复杂;
  2. springboot框架相对亍 springy框架来说,更专注于开发微服务后台接口,不开发前端视图,同时遵循默认优于配置,简化了插件配置流程,不需要配置xm,相对 springmvo,大大简化了配置流程;
- 总结：
  1. Spring框架就像一个家族,有众多衍生产品例如boot、 security、jpa等等。但他们的基础都是 Spring的ioc、aop等.ioc提供了依赖注入的容器,aop解决了面向横切面编程,然后在此两者的基础上实现了其他延伸j品的高级功能;
  2. springmvc主要解决WEB开发的问题,是基于 Servlet的一个MVC框架,通过XML配置,统一开发前端视图和后端逻辑;
  3. 由于 Spring的配置非常复杂,各种XML、 Java config、 servlet处理起来比较繁琐,为了简化开发者的使用,从而创造性地推出了 spring Boot框架,默认优于配置,简化了 springmvc的配置流程;但区别于 springmvc的是,spring Boot专注于单体微服务接口开发,和前端解耦,虽然 springboot可以做成 spring前后台一起开发但是这就有点不符合 spring Boot框架的初衷了

### spring boot中定义bean的方式

1. @bean  注解定义

   ``` java
   @bean
   public xxxService xxxService(){
       return new xxxService();
   }
   ```

2. @Component 注解定义

   ``` Java
   @Component 	
   public class xxxService {
       
   }
   ```

   

3. @Controller、@RestController、@Service、@Repository 注解定义

   ``` java 
   @RestController
   //@Controller
   public class xxxController{
       @GetMapping("/test")
       public String test(){
           return "xxx";
       }
   }
   ```

4. @ControllerAdvice 、@RestControllerAdvice

   ``` java
   @ControllerAdvice
   //@RestControllerAdvice
   public class xxxControllerAdvice{
       @InitBinder
       public void initBinder(WebDataBinder binder){
           .....
       }
   }
   ```

   - @ControllerAdvice相当于对于Controller的切面

5. @Configuration

   ```java 
   @Configuration
   public class xxxConfig{
       
   }
   ```

   -  该注解定义的bean是一个配置bean

6. @Import

   在启动类上直接导入该类即可

7. BeanDefinition 

   所有注册bean 的底层方式，可以继承于ImportBeanDefinitionRegistrar这个类，使用其方法去注册bean

8. <bean/> 标签

### spring的启动流程

具体流程：

1. 在创建spring容器时，也就是启动spring时：
2. 首先会进行扫描，扫描得到所有的BeanDefinition对象，并保存在一个Map中
3. 筛选出非懒加载的单例BeanDefinition进行创建Bean，对于多例Bean不需要再启动时进行创建，会在每次获取Bean时利用BeanDefinition去创建
4. 利用BeanDefinition创建Bean就是Bean的创建周期，这期间包括了合并BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP发生在初始化后
5. 单例Bean创建完后，spring会发布一个容器启动事件
6. spring启动结束
7. 在源码中会更复杂，比如源码中会提供一些模板方法，让子类实现
8. 在spring启动过程中，还会去处理@Import等注解

### spring boot启动流程	

![image-20230302160547985](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230302160547985.png)

![image-20230302160733371](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230302160733371.png)

![img](https://img2020.cnblogs.com/blog/1642959/202008/1642959-20200802005709378-467288808.jpg)

### springboot自动配置

- 原理描述：Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，通过@Bean导入到Spring容器中，以Properties结尾命名的类是和配置文件进行绑定的。它能通过这些以Properties结尾命名的类中取得在全局配置文件中配置的属性，我们可以通过修改配置文件对应的属性来修改自动配置的默认值，来完成自定义配置

### bean的实例化与初始化的区别

- bean的实例化：Spring在创建一个Bean对象时,会先创建出来个Java对象,会通过反射来执行类的构造方法从而得到个Java对象,而这个过程就是Bean的实例化
- bean的初始化：得到Java对象后,会进行依赖注入,依赖注入之后就会进行初始化了,而Bean的初始化就是调用前面创建出来的Java对象中特定的方法,比如lava对象实现了 Initializing Bean接口,那么初始化的时候就会执行Java对象的 lafterproperties Seto, Spring只会执行这个方法,并不关心方法做了什么,我们可以在这个方法中去对某个属性进行验证,或者直接给某个属性赋值都是可以的,反正Bean的初始化就是执行afterpropertiesset0方法,或者执行 Tinit-method指定的方法

### spring AOP是如何实现的

- AOP：为解耦而生

- 利用动态代理机制，如果一个Bean实现了接口，那么就会采用JDK动态代理来生成该接口的代理对象，如果一个Bean没用实现接口，那么就会采用CGLIB来生成一个当前类的代理对象，代理对象的作用就是，代理原本的Bean对象，代理对象在执行某个方法时，会在该方法的基础上，增加一些切面逻辑，使得我们可以利用AOP来实现比如登录校验，权限控制，日志记录等一系列功能。
- 任何一个系统都是由不同的组件组成的,每个组件负责一块特定的功能,当然会存在很多组件是跟业务无关的,例如日志、事务、权限等核心服务组件,这些核心服务组件经常融入到具体的业务逻辑中,如果我们为每一个具体业务逻辑操作都添加这样的代码,很明显代码冗余太多,因此我们需要将这些公共的代码逻辑抽象出来变成一个切面,然后注入到目标对象(具体业务)中去,AOP正是基于这样的一个思路实现的,通过动态代理的方式,将需要注入切面的对象进行代理,在进行调用的时候,将公共的逻辑直接添加进去,而不需要修改原有业务的逻辑代码,只需要在原来的业务逻辑基础之上做一些增強功能即可,

### spring IOC

- IOC——控制反转：
- 将对象的创建和赋值工作交给IOC容器来做，程序员只需要给它提供类的方法和属性，不需要自己去实例化对象。将这部分控制权由程序员本身转移到IOC容器。

### spring 事务的实现

- @Transactional 注解
- 具体实现：
  1. spring事务的底层是基于springAOP机制的
  2. 首先使用了@Transactional 注解的Bean，spring会创建一个代理对象作为Bean
  3. 当调用代理对象的方法时，会先判断该方法是否添加了@Transactional 注解
  4. 如果加了，则由事务管理器创建一个数据库连接
  5. 并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现spring事务的非常重要的一步
  6. 然后执行当前方法，方法中会执行sql命令
  7. 执行完当前方法后，无异常会直接提交事务
  8. 如果出现异常，并且这个异常是需要回滚的，则进行事务回滚，否则任然提交事务
  9. spring事务的隔离级别就对应数据库的隔离级别
  10. spring事务的传播机制是spring事务自己实现的，也是spring中最复杂的
  11. spring事务的传播机制是基于数据库连接做的，一个数据库连接一个事务，如果传播机制配置为需要新开一个事务，那么实际上就是新建一个数据库连接，在新的数据库连接上执行sql语句

### 事务的传播机制

多个事务方法相互调用时（例如：A类a()调用B类b()方法）事务是如何在方法中进行传播的。有7种传播特性。

1. Required：默认的传播特性，如果当前没有事务，则新建一个事务，如果当前存在事务，则加入这个事务
2. Supports：当前存在事务，则加入此事务，如果当前没有事务，则以非事务的方式执行。
3. Mandatory：当前存在事务，则加入此事务，当前事务不存在，抛出异常。
4. Required_New：创建一个新事务，如果当前事务存在，则挂起该事务。
5. Not_Supported：以非事务的方式执行，如果当前事务存在，则挂起该事务。
6. Never：不使用事务，如果当前事务存在，则抛出异常
7. Nested：如果当前事务存在，则在嵌套进事务中执行，否则和Required的操作一样

- 所谓开一个新的事务，就是新建一个数据库连接，而加入事务而是基于之前的数据库连接来执行sql

### 事务失效的场景及原因

![image-20230302181013536](C:\Users\杨\AppData\Roaming\Typora\typora-user-images\image-20230302181013536.png)

### spring创建Bean周期的步骤

1. 推断构造方法：默认无参，若存在多个有参，需要使用@Autoword注解标注。
2. 实例化
3. 填充属性，也就是依赖注入
4. 处理Aware回调
5. 初始化前，处理@PostConstruct注解标注的方法
6. 初始化：处理InitializingBean接口
7. 初始化后，进行AOP

### spring中bean是否是线程安全的

spring本身并没有对Bean做线程安全的处理，所以：

1. 如果Bean是无状态的，那么Bean是安全的
2. 如果Bean是有状态的，那么Bean是不安全的

- Bean是不是线程安全和Bean的作用域没关系，Bean的作用域只是表示Bean的生命周期范围，对于任何生命周期，Bean都是一个对象，是否线程安全得看它本身

### ApplicationContext和BeanFactory的区别

BeanFactory是spring中非常核心的组件，表示Bean工厂，可以生成Bean，维护Bean，两个都是接口，而ApplicationContext则继承了BeanFactory，所以ApplicationContext在拥有BeanFactory特点的基础上，还有继承了很多其它的接口，这些功能是BeanFactory所不具备的

### @SpringBootApplication注解有什么用

- @SpringBootApplication是一个复合注解

  ``` java 
  @SpringBootConfiguration
  @EnableAutoConfiguration
  @ComponentScan
  public @interface SpringBootApplication {
  ....
  }
  ```

- 是以上三个注解的整合，在一个类上添加了@SpringBootApplication注解，相当于这个类有：

  1. @ComponentScan，从而Spring容器会进行扫描，扫描路径为当前在解析的这个类所在的包路径
  2. @EnableAutoConfiguration：这个注解会复杂自动配置类的导入，也就是将项目中的自动配置类导入到spring容器中，从而得到解析
  3. @SpringBootConfiguration：它其实相当于@Configuration注解，表示当前类是一个配置类

- 所以，在使用Springboot时，我们一般会在主类上加上@SpringBootApplication这个注解，加上之后，springBoot就会进行扫描，就会导入自动配置类，并进行解析。
